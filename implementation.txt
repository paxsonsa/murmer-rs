# Remote Actor Registration and Type-Safe Downcasting Implementation

## Original Problem Statement

The actor system needs a mechanism to properly downcast `AnyEndpoint` instances to typed endpoints, especially for remote actors registered in the receptionist. The current system doesn't provide sufficient type information to safely downcast when dealing with remote actors.

## Implemented Solution

We've implemented an inventory-based approach for actor and message type registration that allows:

1. Dynamic registration of actor types without a centralized registry
2. Type-safe downcasting of remote actor proxies
3. Selective exposure of messages for remote communication
4. Proper serialization/deserialization of messages across node boundaries

## Implementation Status

### Phase 1: Type Registration Framework (‚úÖ COMPLETED)

- Added the `inventory` crate to the project
- Created type registration structs:
  - `ActorTypeRegistration`: For registering actor types with string keys
  - `MessageTypeRegistration`: For registering message types that can be handled remotely
- Implemented the `RemoteRegistered` trait extending the existing `Registered` actor trait
- Set up inventory collection points for registrations

Implemented code:
```rust
/// Registration for actor types in the inventory system
pub struct ActorTypeRegistration {
    /// String identifier for this actor type
    pub key: &'static str,
    /// Type name for debugging and error messages
    pub type_name: &'static str,
    /// Factory function to create remote endpoints for this actor type
    pub create_endpoint: fn(ActorPath) -> AnyEndpoint,
}

impl ActorTypeRegistration {
    pub const fn new(
        key: &'static str,
        type_name: &'static str,
        create_endpoint: fn(ActorPath) -> AnyEndpoint,
    ) -> Self {
        Self {
            key,
            type_name,
            create_endpoint,
        }
    }
}

inventory::collect!(ActorTypeRegistration);

/// Registration for message types that can be sent to remote actors
pub struct MessageTypeRegistration {
    /// Actor type this message applies to
    pub actor_type: &'static str,
    /// Message type identifier
    pub message_type: &'static str,
    /// Function to serialize message, send to remote, and deserialize response
    pub handler: fn(Bytes) -> Result<Bytes, String>,
}

inventory::collect!(MessageTypeRegistration);

/// Trait for messages that can be sent remotely
pub trait RemoteMessageType: Message + Serialize + for<'de> Deserialize<'de> {
    /// Unique identifier for this message type
    const TYPE_ID: &'static str;
}

/// Extended registration trait for actors that can be accessed remotely
pub trait RemoteRegistered: RegisteredActor {
    /// Creates a properly typed endpoint for a remote actor of this type
    fn create_remote_endpoint(path: ActorPath) -> AnyEndpoint;

    /// Returns handlers for all message types supported by this actor remotely
    fn message_handlers() -> Vec<(&'static str, fn(Bytes) -> Result<Bytes, String>)>;
}
```

### Phase 2: Macro Support (‚úÖ COMPLETED)

- Implemented `register_remote_actor!` macro to register actor types in the inventory
- Implemented `remote_message!` macro to register message types in the inventory
- Added the `paste` crate for handling token concatenation in macros
- Created proper module isolation to avoid name conflicts

Implemented code:
```rust
#[macro_export]
macro_rules! register_remote_actor {
    ($actor_type:ty, $key:expr) => {
        // Create a module to avoid name conflicts
        mod __actor_registration_module {
            use super::*;
            use $crate::system::AnyEndpoint;
            use $crate::path::ActorPath;
            use std::sync::Arc;
            use std::any::TypeId;
            
            // Define a function for creating remote endpoints for this actor type
            pub fn create_endpoint(path: ActorPath) -> AnyEndpoint {
                let actor_path = Arc::new(path);
                
                // In a real implementation, we would create a RemoteEndpointSender
                // and wrap it in an Endpoint, but for now we'll return a dummy AnyEndpoint
                AnyEndpoint {
                    endpoint_sender: Box::new(()),
                    type_id: TypeId::of::<$actor_type>(),
                    type_name: std::any::type_name::<$actor_type>(),
                    path: actor_path.clone(),
                    actor_type_string: Some($key.to_string()),
                }
            }
            
            // Create the static registration entry
            inventory::submit! {
                $crate::remote::ActorTypeRegistration::new(
                    $key,
                    stringify!($actor_type),
                    create_endpoint
                )
            }
        }
    };
}

#[macro_export]
macro_rules! remote_message {
    ($actor_type:ty, $message_type:ty, $type_id:expr) => {
        impl $crate::remote::RemoteMessageType for $message_type {
            const TYPE_ID: &'static str = $type_id;
        }
        
        // Create a module to avoid name conflicts
        paste::paste! {
            mod [<__message_registration_module_ $message_type>] {
                use super::*;
                use bytes::Bytes;
                
                // Define a handler function for this message type
                pub fn handle_message(bytes: Bytes) -> Result<Bytes, String> {
                    // Deserialize the message
                    let config = bincode::config::standard();
                    let msg = bincode::decode_from_slice::<$message_type, _>(&bytes, config)
                        .map_err(|e| format!("Deserialization error: {}", e))?
                        .0;
        
                    // Create a temporary endpoint to handle this message
                    // This is a placeholder - in the actual implementation
                    // we'd send the message to the actor and get its response
                    let response = match bincode::encode_to_vec(&msg, config) {
                        Ok(r) => r,
                        Err(e) => return Err(format!("Serialization error: {}", e)),
                    };
        
                    Ok(Bytes::from(response))
                }
                
                // Register the message handler with the inventory system
                inventory::submit! {
                    $crate::remote::MessageTypeRegistration::new(
                        <$actor_type as $crate::actor::Registered>::RECEPTIONIST_KEY,
                        $type_id,
                        handle_message
                    )
                }
            }
        }
    };
}
```

### Phase 3: Remote Proxy Implementation (‚ö†Ô∏è PARTIALLY COMPLETE)

- Enhanced `AnyEndpoint` to include string-based type information via `actor_type_string` field
- Updated `downcast` and `into_downcast` methods to support string-based lookup
- Added basic placeholder functionality for creating remote endpoints
- Started implementing support for serialized message handling

Implemented code:
```rust
impl AnyEndpoint {
    /// Attempt to downcast the AnyEndpoint back to a specific Endpoint<A> type
    pub fn downcast<A: Actor + 'static>(&self) -> Option<Endpoint<A>> {
        // For local actors - try direct TypeId-based downcasting
        if self.path.is_local() && self.type_id == TypeId::of::<A>() {
            return self.endpoint_sender
                .downcast_ref::<EndpointSender<A>>()
                .map(|b| {
                    let sender = b.clone();
                    Endpoint::new(sender, self.path.clone())
                });
        }
        
        // For remote actors - use the actor_type_string with inventory lookup
        if self.path.is_remote() {
            // Check if A implements RegisteredActor first
            if let Some(receptionist_key) = self.actor_type_string.as_ref() {
                // Search the inventory for a matching registration
                for registration in inventory::iter::<crate::remote::ActorTypeRegistration>() {
                    if registration.key == receptionist_key {
                        // Found matching registration, create typed endpoint
                        let any_endpoint = (registration.create_endpoint)((*self.path).clone());
                        return any_endpoint.downcast::<A>();
                    }
                }
            }
        }
        
        None
    }
}
```

### Phase 4: Receptionist Integration (‚ö†Ô∏è PARTIALLY COMPLETE)

- Enhanced `Receptionist` to support remote registration with the `register_remote` method
- Added accessors for `RawKey` fields (receptionist_key and group_id)
- Updated `network.rs` to provide host and port accessors for path construction

### Phase 5: Testing and Documentation (üîÑ IN PROGRESS)

- Added tests for inventory registration for both actor types and message types
- Fixed macro syntax to properly use the inventory system

## Usage Example (Current Implementation)

```rust
// First, define a simple actor
pub struct UserActor {
    name: String,
    user_id: String,
}

impl Actor for UserActor {}

impl Registered for UserActor {
    const RECEPTIONIST_KEY: &'static str = "user-actor";
}

// Implement RemoteRegistered trait
impl RemoteRegistered for UserActor {
    fn create_remote_endpoint(path: ActorPath) -> AnyEndpoint {
        AnyEndpoint {
            endpoint_sender: Box::new(()),
            type_id: std::any::TypeId::of::<UserActor>(),
            type_name: std::any::type_name::<UserActor>(),
            path: Arc::new(path),
            actor_type_string: Some("user-actor".to_string()),
        }
    }
    
    fn message_handlers() -> Vec<(&'static str, fn(Bytes) -> Result<Bytes, String>)> {
        vec![
            // We would populate this with our message handlers from the inventory
            ("get-user-profile", |_| Ok(Bytes::new()))
        ]
    }
}

// Register the actor type with the remote system
register_remote_actor!(UserActor, "user-actor");

// Define a message that can be sent to our actor
#[derive(Debug, Serialize, Deserialize, bincode::Encode, bincode::Decode)]
pub struct GetUserProfile {
    pub user_id: String,
}

// Register the message as remote-capable
remote_message!(UserActor, GetUserProfile, "get-user-profile");
```

## Next Steps

1. **Complete the Remote Endpoint Implementation**:
   - Create a proper `RemoteEndpointSender` implementation
   - Implement serialization and deserialization of messages
   - Add proper error handling for remote communication

2. **Enhance Message Handling**:
   - Connect the inventory-based message registration with the actual message handling
   - Implement message routing for remote actors

3. **Full Integration Testing**:
   - Create more complex examples with multiple actor and message types
   - Test remote actor communication across node boundaries
   - Verify proper downcasting of endpoints based on string identifiers

4. **Documentation**:
   - Add comprehensive documentation for the remote actor system
   - Include usage examples and best practices

## Advantages of the Implemented Solution

- **Runtime Type Safety**: String-based identifiers provide a stable way to identify actor types across node boundaries
- **Cross-compilation Support**: Independence from TypeId's which can vary between compilation units
- **Decentralized Registration**: No central registry needed; each actor registers itself
- **Graceful Degradation**: Local actors can still use TypeId-based downcasting for efficiency
- **Explicit Opt-in**: Only actors explicitly registered can be accessed remotely, providing better control